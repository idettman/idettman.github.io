/*** @author Steve Shipman* @version 0.1*/package com.suckatmath.detector.classifier{	import flash.geom.Rectangle;	import flash.utils.getTimer;	/**	* HaarClassifier is the top level of a Haar Classifier.  It has a native width and height and several stages.	* Corresponds to <... type_id="opencv-haar-classifier">	* 	*/	public class HaarClassifier	{		/**		 * width in pixels		 */		public var width:int;		/**		 * height in pixels		 */		public var height:int;		/**		 * original width (before any scaling)		 */		public var origwidth:int;		/**		 * original height (before any scaling)		 */		public var origheight:int;		/**		 * inverse window area.  1/(width times height).  Used for normalization		 */		public var inv_window_area:Number;				public var stageList:StageList;  //typed lists are supposed to be 2-3x faster than arrays		private var sqrt:Function = Math.sqrt;		/**		 * Create a new classifier.  Usually you won't use this, instead reading from XML using the fromXML method		 * @paramw  native width in pixels.		 * @paramh  native height in pixels.		 */		public function HaarClassifier(w:int = 0, h:int = 0):void		{			this.width = w;			this.origwidth = w;			this.height = h;			this.origheight = h;			this.stageList = new StageList();		}		/**		 * reads a HaarClassifier from an XML file.  Several such files are provided by the Intel OpenCV project.  This class intends to be		 * compatible with those files, but is NOT associated with the OpenCV project.		 * 		 * @paramxml		 * @return HaarClassifier described by the xml		 */		public static function fromXML(xml:XML):HaarClassifier		{			var sizes:XML = xml.size.text()[0];			//trace("sizes: " + sizes.toString());			var sizesArr:Array = sizes.toString().match( /\d+/g );			var toreturn:HaarClassifier = new HaarClassifier(sizesArr[0], sizesArr[1]);			var stagesList:XMLList = xml.stages[0].children();			var astage:HaarClassifierStage;			for each (var s:XML in stagesList)			{				astage = HaarClassifierStage.fromXML(s);				astage.setClassifier(toreturn);				toreturn.stageList.add(astage);			}			return toreturn;		}		/**		 * serialize this classifier to an XML string suitable for writing to a file.  Should be compatible with OpenCV, but not identical.		 * some nodes which OpenCV represents as "_" are more verbose.		 * 		 * @return String		 */		public function toXMLString():String		{			var toreturn:String =  '<HaarClassifier type="opencv-haar-classifier"><size> ' + origwidth + " " + origheight + "</size><stages>";			var cStage:StageCell = stageList.head;			while(cStage)			{				toreturn += "\n" + cStage.elt.toXMLString();				cStage = cStage.next;			}			toreturn += "</stages></HaarClassifier>";			return toreturn;		}		/**		  *  iteratively evaluates stages.  Passes if ALL stages pass.		 * 		 * @paramii - IntegralImage		 * @paramr - window on which to evaluate.		 * @return true if ALL stages pass.  false otherwise.		 */		public function evaluateSubImage(ii:IntegralImage, r:Rectangle):Boolean		{			var mean:Number = ii.getRectSum(r) * inv_window_area;			var vnorm:Number = (ii.getRectSqSum(r) * inv_window_area) - (mean * mean);			vnorm = (vnorm > 0) ? sqrt(vnorm) : 1			var cStage:StageCell = stageList.head;			while(cStage)			{				if(!cStage.elt.evaluateSubImage(ii, r, vnorm))				{					return false				}				cStage = cStage.next;			}			return true		}		/**		 * scales this classifier from width * height to r.		 * Does so by scaling all rectangle features in subtrees.		 * @paramr window to scale to.		 */		public function setScale(r:Rectangle):void		{			var cStage:StageCell = stageList.head;			while (cStage)			{				cStage.elt.setScale(origwidth, r);				cStage = cStage.next;			}			height = r.width;			width = r.width;			inv_window_area = 1 / (width *width);		}				public function clone():HaarClassifier {			var toreturn:HaarClassifier = new HaarClassifier(width, height);			var cStage:StageCell = stageList.head;			while(cStage)			{				toreturn.stageList.add(cStage.elt.clone());				cStage = cStage.next;			}			return toreturn;		}	}}