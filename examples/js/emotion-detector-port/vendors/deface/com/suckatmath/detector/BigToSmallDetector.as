/*** @author Steve Shipman* @version 0.1*/package com.suckatmath.detector{	import com.suckatmath.detector.classifier.HaarClassifier;	import com.suckatmath.detector.classifier.IntegralImage;	import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.display.IBitmapDrawable;	import flash.geom.Rectangle;	import flash.utils.getTimer;	/**	 * A BigToSmallDetector goes from large scales to smaller scales.  Large passes are faster (because there are less large rects per line)	 * and this can be FAR faster than default small-to-large detection.  The cost is decreased accuracy, but for many purposes this is perfectly	 * acceptable (any detected face will still be within the reported rect)	*/	public class BigToSmallDetector extends Detector	{				/**		 * 		 * @param hc  classifier determining feature(s) to recognize		 * @param md  maximum number of matching rectangles to return - May not correspond to actual distinct features as same feature		 * can be detected at multiple enclosing rectangles		 * @param minscale minimum of smallest dimension of classifier.		 */		public function BigToSmallDetector(hc:HaarClassifier = null, md:int = 1, minscale:int = 20):void		{			super(hc, md, minscale);		}		/**		 * Just like detect, but allows re-use of Integral Image for different detectors on the same image		 * 		 * scan classifier across ii at DECREASING scales, looking for objects.		 * decreasing scale allows larger (presumably closer) faces to be found first.  In the case of looking for a single face, this can be much		 * faster than increasing scale.		 * Will find at most maxDetect faces.  If maxDetect == -1, find ALL.		 * 		 * @param ii:IntegralImage		 * @param boundaryRect:Rectangle - a rectangle describing the area of the image in which to look.  If null, entire image is used		 * 		 * @return Vector of Rectangles describing areas where objects were found.		 */		public override function detectOnII(ii:IntegralImage, boundaryrect:Rectangle = null):Vector.<Rectangle>		{			//performance testing.  uncomment if you feel like it			//var begin:int = getTimer();			if (boundaryrect == null)			{				boundaryrect = new Rectangle(0, 0, ii.getWidth() -1, ii.getHeight() - 1);			}			var cw:int = classifier.width			var scale:Number = boundaryrect.width / cw;			if ((cw * scale)>>0 > boundaryrect.height)			{				scale = boundaryrect.height / cw;			}			var rectsize:int = (scale * cw)>>0			var rect:Rectangle = new Rectangle(0, 0, rectsize, rectsize);			var ret:Vector.<Rectangle> = new Vector.<Rectangle>();			var s:int = rectsize;			//performance testing			//var scaleTime:int = 0;			do			{				//performance testing				//var b4:int = getTimer();				classifier.setScale(rect);				//scaleTime += (getTimer() - b4);								scanImage(classifier, ii, rect, boundaryrect, ret);				if ((md != -1) && (ret.length >= md))				{					//trace("md: " + md);					//var took:Number = getTimer() - begin					//trace("took: " + took + "ms.  scaleTime:" + scaleTime);					return ret;				}				s -= 8; //TUNABLE, in concert with tracker min size				rect.width=rect.height=s			} while (s >= minscale);			if (ret.length > 0) {				return ret;			}			return null;		}			}}