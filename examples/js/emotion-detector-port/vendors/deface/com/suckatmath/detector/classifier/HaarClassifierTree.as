/*** * @author Steve Shipman* @version 0.1*/package com.suckatmath.detector.classifier{	import flash.geom.Rectangle;	/**	 * A Haar Classifier Tree is an element of a HaarClassifierStage.  These have an array of nodes (one or more), which form a tree.	 */	public class HaarClassifierTree	{		/**		 * Array of HaarClassifierFeature		 */		public var nodes:Vector.<HaarClassifierFeature>; //Array;		public function HaarClassifierTree()		{			nodes = new Vector.<HaarClassifierFeature>();		}		/**		 * create a classifier tree from xml.  Should be compatible with OpenCV classifiers, but not guaranteed.		 * @paramxml subtree representing a classifier tree		 * @return HaarClassifierTree		 */		public static function fromXML(xml:XML):HaarClassifierTree		{			var toreturn:HaarClassifierTree = new HaarClassifierTree();			var nodeNodes:XMLList = xml.elements();//does NOT include comments			var feat:HaarClassifierFeature;			for each (var featNode:XML in nodeNodes)			{				feat = HaarClassifierFeature.fromXML(featNode);				feat.parent = toreturn;				toreturn.nodes.push(feat);			}			return toreturn;		}				public function clone():HaarClassifierTree {			var toreturn:HaarClassifierTree = new HaarClassifierTree();			for (var i:int = 0; i < nodes.length; i++)			{				toreturn.nodes.push(nodes[i].clone());			}			return toreturn;		}				/**		 * serialize this classifier tree to xml.  Should be compatible with OpenCV but not identical		 * @return String version of this classifier tree as xml		 */		public function toXMLString():String		{			var toreturn:String = "<HaarClassifierTree>";			for (var i:int = 0; i < nodes.length; i++)			{				toreturn += "\n" + nodes[i].toXMLString();			}			toreturn += "</HaarClassifierTree>";			return toreturn;		}		/**		 * evaluate root node (feature).  The individual features control tree traversal among siblings.		 * @paramii IntegralImage to use for sums		 * @paramr Rectangle window to evaluate		 * @paramvnorm Number variance normalization factor		 * @return		 */		public function evaluateSubImage(ii:IntegralImage, r:Rectangle, vnorm:Number):Number		{			return nodes[0].evaluateSubImage(ii,r,vnorm);		}		public function setClassifier(cfer:HaarClassifier):void {			var nl:int = nodes.length;			for each (var cNode:HaarClassifierFeature in nodes)			{				cNode.setClassifier(cfer);			}		}				/**		 * scale this tree to r by scaling each child node.		 * @paramw original classifier width		 * @paramh original classifier height		 * @paramr new window Rectangle		 */		public function setScale( s:int, r:Rectangle):void		{			for each (var cNode:HaarClassifierFeature in nodes)			{				cNode.setScale(s,r);			}		}	}}