/*** @author Steve Shipman* @version 0.1*/package com.suckatmath.detector{	import com.suckatmath.detector.classifier.HaarClassifier;	import com.suckatmath.detector.classifier.IntegralImage;	import com.suckatmath.detector.classifier.BasicIntegralImage;	import com.suckatmath.detector.classifier.MarilenaLikeIntegralImage;		import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.display.IBitmapDrawable;	import flash.geom.Rectangle;	import flash.utils.getTimer;	/**	 * A Detector applies a HaarClassifier to an Image, getting back an Array of Rectangles representing matching areas of the image.	     */	public class Detector	{		/**		 * The classifier to use to determine whether an image area matches.		 */		public var classifier:HaarClassifier;		/**		 * size of smallest feature to find (in pixels).  		 * Higher values give faster performance, lower give more thorough.		 */		public var minscale:int;				/**		 * maximum detected.  default 1, -1 for no limit.		 */		public var md:int;				public var ii:IntegralImage				private var bd:BitmapData		/**		 * @private		 */		protected static  var max:Function = Math.max;		/**		 * 		 * @param hc  classifier determining feature(s) to recognize		 * @param md  maximum number of matching rectangles to return - May not correspond to actual distinct features as same feature		 * can be detected at multiple enclosing rectangles		 * @param minscale minimum of smallest dimension of classifier.		 */		public function Detector(hc:HaarClassifier = null, md:int = 1, minscale:int = 20):void		{			classifier = hc;			this.md = md;			this.minscale = minscale;		}				public function set bitmap(bd:BitmapData):void		{			trace("SET BITMAP")			this.bd=bd			//this.ii = new BasicIntegralImage(bd);            this.ii = new MarilenaLikeIntegralImage(bd);		}				public function get bitmap():BitmapData {			return bd;		}				/**		 * scan classifier across bd at DECREASING scales, looking for objects.		 * Decreasing scales allow bigger (probably closer) objects to have priority.		 * Will find at most maxDetect objects.  If maxDetect == -1, find ALL.		 * 		 * @param bd BitmapData on which to search		 * @param boundaryRect a rectangle describing the area of the image in which to look.  If null, entire image is used		 * 		 * @return Array of Rectangles describing areas where objects were found.		 */		public function detect(boundaryRect:Rectangle = null):Vector.<Rectangle>		{			this.ii.update()			return detectOnII(ii,boundaryRect);		}		/**		 * Just like detect, but allows re-use of Integral Image for different detectors on the same image		 * 		 * scan classifier across ii at INCREASING scales, looking for objects.		 * increasing scale allows minimal rectangles to be found first, and prevent processing redundant rectangles.		 * Will find at most maxDetect faces.  If maxDetect == -1, find ALL.		 * 		 * @param ii:IntegralImage		 * @param boundaryRect:Rectangle - a rectangle describing the area of the image in which to look.  If null, entire image is used		 * 		 * @return Array of Rectangles describing areas where objects were found.		 */		public function detectOnII(ii:IntegralImage, boundaryrect:Rectangle = null):Vector.<Rectangle>		{			if (boundaryrect == null)			{				boundaryrect = new Rectangle(0, 0, ii.getWidth() -1, ii.getHeight() - 1);			}			var cw:int = classifier.width			var scale:Number = boundaryrect.width / cw;			if ((cw * scale)>>0 > boundaryrect.height)			{				scale = boundaryrect.height / cw;			}			var rectsize:int = (scale * cw)>>0			var rect:Rectangle = new Rectangle(0, 0, rectsize, rectsize);			var ret:Vector.<Rectangle> = new Vector.<Rectangle>();			var s:int = minscale;			do			{				classifier.setScale(rect);				scanImage(classifier, ii, rect, boundaryrect, ret);				if ((md != -1) && (ret.length >= md)) {					//trace("md: " + md);					return ret;				}				s += 8; //TUNABLE, in concert with tracker min size				rect.width=rect.height=s			} while (s <= rectsize); //(s > minscale);			if (ret.length > 0) {				return ret;			}			return null;		}				/**		 * scans a classifier at a particular scale across an image from left to right and top to bottom		 * stores matches in input toreturn array.		 * 		 * @param classifier HaarClassifier		 * @param ii IntegralImage		 * @param rect Rectangle describing sliding classifier window - x,y will be changed		 * @param boundaryrect Rectangle describing search window		 * @param toreturn Array in which to store matches		 */		protected function scanImage(classifier:HaarClassifier, ii:IntegralImage, rect:Rectangle, boundaryrect:Rectangle, toreturn:Vector.<Rectangle>):void		{			var cw:int = classifier.width			var step:int = max(((cw / classifier.origwidth)<<1)>>0, 2) // the * 2 is new.  increases speed at the cost of slightly higher probability 			//of missing a valid face.  Classifiers are robust though, and usually will find face at next or prev rect as well.			var ylim:int = boundaryrect.y + boundaryrect.height;			var xlim:int = boundaryrect.x + boundaryrect.width;			rect.y = boundaryrect.y;			while ((cw + rect.y) < ylim)			{				rect.x = boundaryrect.x;				while ((cw + rect.x) < xlim)				{					for (var i:int = 0; i < toreturn.length; i++) {						if (rect.containsRect(toreturn[i])) {							rect.x = toreturn[i].x + toreturn[i].width;						}					}					if (classifier.evaluateSubImage(ii, rect))					{						toreturn.push(rect.clone());						if ((md != -1) && (toreturn.length >= md)) {							return;						}					}					rect.x += step;				}				rect.y += step;			}		}			}}