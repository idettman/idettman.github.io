/*** * @author Steve Shipman* @version 0.1*/package com.suckatmath.detector.classifier{	import flash.geom.Rectangle;	/**	 * A Haar Classifier Feature is an element of a HaarClassifierTree.	 * 	 * As a Feature, it has rects, threshold, leftval, rightval, left index, right index	 */	public class HaarClassifierFeature	{				public var rectList:RectList;				/**		 * threshold to compare sums against		 */		public var threshold:Number;//float		/**		 * whether this feature is "tilted" 45 degrees		 */		public var tilted:Boolean;		/**		 * Number to return if sums are less than threshold.  May be NaN iff leftIdx != NaN		 */		public var leftval:Number;//float.  may be NaN iff leftIdx != NaN		/**		 * Number to return if sums are more than threshold.  May be NaN iff rightIdx != NaN		 */		public var rightval:Number;//float. may be NaN iff rightIdx != NaN		/**		 * index in parent of left child feature.  May be NaN iff leftval != NaN		 */		public var leftIdx:int;//index in parent of left child feature.  may be null iff leftval != null		/**		 * index in parent of right child feature.  May be NaN iff rightval != NaN		 */		public var rightIdx:int;//index in parent of left child feature.  may be null iff leftval != null				private var hasLeftNode:Boolean;		private var hasRightNode:Boolean;				public var classifier:HaarClassifier;		/**		 * parent HaarClassifierTree.  Used for tree traversal.		 */		public var parent:HaarClassifierTree;//parent tree.  used for traversal.		public function HaarClassifierFeature()		{			rectList = new RectList();		}		/**		 * read a feature from an xml node.  Intended to be compatible with OpenCV xml classifiers, but this project is NOT associated		 * with OpenCV		 * @param xml subtree representing a classifier feature		 * @return HaarClassifierFeature		 */		public static function fromXML(xml:XML):HaarClassifierFeature		{			var toreturn:HaarClassifierFeature = new HaarClassifierFeature();			toreturn.threshold = parseFloat(xml.threshold.text()[0].toString());			//test for left_val.			if (xml.descendants("left_val").length() > 0)			{				toreturn.leftval = parseFloat(xml.left_val.text()[0].toString());				toreturn.leftIdx = NaN;				toreturn.hasLeftNode = false;			}			else			{				toreturn.leftIdx = parseInt(xml.left_node.text()[0].toString());				toreturn.hasLeftNode = true;				toreturn.leftval =  NaN;			}			//test for right_val.			if (xml.descendants("right_val").length() > 0)			{				toreturn.rightval = parseFloat(xml.right_val.text()[0].toString());				toreturn.rightIdx = NaN;				toreturn.hasRightNode = false;			}			else			{				toreturn.rightIdx = parseInt(xml.right_node.text()[0].toString());				toreturn.rightval = NaN;				toreturn.hasRightNode = true;			}			toreturn.tilted = (parseInt(xml.feature.tilted.text()[0].toString()) == 1);			var rectsnodes:XMLList = xml.feature.rects.children();			//we ignore tilted as well, since it's always 0 in our example			var rarray:Array;//of String.  Basically the numbers in the individual rect nodes			var x:int;			var y:int;			var w:int;			var h:int;			var weight:Number;			for each (var r:XML in rectsnodes)			{				rarray = r.text()[0].toString().split(" ");				x = parseInt(rarray[0]);				y = parseInt(rarray[1]);				w = parseInt(rarray[2]);				h = parseInt(rarray[3]);				weight = parseFloat(rarray[4]);				toreturn.rectList.add(new HaarRect(x, y, w, h, weight));			}			return toreturn;		}				public function clone():HaarClassifierFeature {			var toreturn:HaarClassifierFeature = new HaarClassifierFeature();			toreturn.threshold = threshold;			toreturn.tilted = tilted;			toreturn.leftval = leftval;			toreturn.rightval = rightval;			toreturn.leftIdx = leftIdx;			toreturn.rightIdx = rightIdx;			toreturn.hasLeftNode = hasLeftNode;			toreturn.hasRightNode = hasRightNode;			var cRect:RectCell = rectList.head;			while (cRect)			{				toreturn.rectList.add(cRect.elt.clone());				cRect = cRect.next;			}			return toreturn;		}		/**		 * serialize this feature to an xml string.  Intended to be compatible with OpenCV but not identical.		 * @return String version of this classifier feature as xml		 */		public function toXMLString():String		{			var toreturn:String = "<HaarClassifierFeature><feature><rects>";			var cRect:RectCell = rectList.head;			while (cRect)			{				toreturn += "\n" + cRect.elt.toXMLString();				cRect = cRect.next;			}			toreturn += "</rects><tilted>";			if (tilted)			{				toreturn += "1";			}			else			{				toreturn += "0";			}			toreturn += "</tilted></feature>";			toreturn += "\n<threshold>" + threshold + "</threshold>";			if (!hasLeftNode)			{				toreturn += "<left_val>" + leftval + "</left_val>";			}			else			{				toreturn += "<left_node>" + leftIdx +"</left_node>";			}			if (!hasRightNode)			{				toreturn += "<right_val>" + rightval + "</right_val>";			}			else			{				toreturn += "<right_node>" + rightIdx +"</right_node>";			}			toreturn += "</HaarClassifierFeature>";			return toreturn;		}		/**		 * evaluates this feature in the context of a search window.		 * This implementation assumes that the parent tree is stump-based, and will not recursively traverse tree nodes.		 * 		 * @param ii IntegralImage to use for sums		 * @param r Rectangle window in which to look		 * @param vnorm Number variance normalization factor.		 * @return Number which is either leftval, rightval, or the result of evaluating a sibling feature		 */		public function evaluateSubImage(ii:IntegralImage, r:Rectangle, vnorm:Number):Number		{			var rectsTot:Number = 0.0;			var rres:Number;			var cRect:RectCell = rectList.head;			while (cRect) {				rres = cRect.elt.evaluateSubImage(ii, r, tilted);				rectsTot += rres;				cRect = cRect.next;			}			rectsTot *= classifier.inv_window_area;			if (rectsTot >= (threshold * vnorm))			{				if (!hasRightNode){					return rightval;				}else {					//trace('eval (right) node ' + rightIdx);					return parent.nodes[rightIdx].evaluateSubImage(ii, r, vnorm);				}			}			else			{				if (!hasLeftNode){					return leftval;				}else {					//trace('eval (left) node ' +leftIdx);					return parent.nodes[leftIdx].evaluateSubImage(ii, r, vnorm);				}			}		}		public function setClassifier(cfer:HaarClassifier):void {			classifier = cfer;			var cRect:RectCell = rectList.head;			while (cRect) {			  cRect.elt.setClassifier(cfer);			  cRect = cRect.next;			}		}				/**		 * Scales this feature to the new size of a window		 * @param s original size		 * @param r new Rectangle window.		 */		public function setScale(s:int, r:Rectangle):void		{			var cRect:RectCell = rectList.head;			while (cRect) {				cRect.elt.setScale(s, r);				cRect = cRect.next;			}		}	}}