<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tips for Writing Code Comments</title>
  <link href="https://fonts.googleapis.com/css?family=Merriweather+Sans" rel="stylesheet">
  <link rel="stylesheet" href="style.css"/>
</head>
<body>
<header>
  <h1>Code Comments Examples</h1>
</header>
<div class="left-navigation display-block">
  <ul class="navcontainer top-links bgcolor-black">
    <li id="site-navigation-container"></li>
  </ul>
</div>
<div class="content stackedit__html"><div id="appContainer"></div>
  <code>/**
    * Base class helpers for the updating state of a component.
    */

    /**
    * Sets a subset of the state. Always use this to mutate
    * state. You should treat `this.state` as immutable.
    *
    * There is no guarantee that `this.state` will be immediately updated, so
    * accessing `this.state` after calling this method may return the old value.
    *
    * There is no guarantee that calls to `setState` will run synchronously,
    * as they may eventually be batched together.  You can provide an optional
    * callback that will be executed when the call to setState is actually
    * completed.
    *
    * When a function is provided to setState, it will be called at some point in
    * the future (not synchronously). It will be called with the up to date
    * component arguments (state, props, context). These values can be different
    * from this.* because your function may be called after receiveProps but before
    * shouldComponentUpdate, and this new state, props, and context will not yet be
    * assigned to this.
    *
    * @param {object|function} partialState Next partial state or function to
    *        produce next partial state to be merged with current state.
    * @param {?function} callback Called after state is updated.
    * @final
    * @protected
    */


    /**
    * Forces an update. This should only be invoked when it is known with
    * certainty that we are **not** in a DOM transaction.
    *
    * You may want to call this when you know that some deeper aspect of the
    * component's state has changed but `setState` was not called.
    *
    * This will not invoke `shouldComponentUpdate`, but it will invoke
    * `componentWillUpdate` and `componentDidUpdate`.
    *
    * @param {?function} callback Called after update is complete.
    * @final
    * @protected
    */


    /**
    * Convenience component with default shallow equality check for sCU.
    */

    // Avoid an extra prototype jump for these methods.

    // If a component has string refs, we will assign a different object later.

    /**
    * Escape and wrap key so it is safe to use as a reactid
    *
    * @param {string} key to be escaped.
    * @return {string} the escaped key.
    */

    if (type === 'undefined' || type === 'boolean') {
    // All of the above are perceived as null.
    children = null;
    }


    if (invokeCallback) {
    callback(
    traverseContext,
    children,
    // If it's the only child, treat the name as if it was wrapped in an array
    // so that it's consistent if the number of children grows.
    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar,
    );
    return 1;
    }


    let child;
    let nextName;
    let subtreeCount = 0; // Count of children found in the current subtree.
    const nextNamePrefix =
    nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

    
    if (__DEV__) {
    // Warn about using Maps as children
    if (iteratorFn === children.entries) {
  </code>
</div>
<script src="site-navigation.js"></script>
</body>
</html>